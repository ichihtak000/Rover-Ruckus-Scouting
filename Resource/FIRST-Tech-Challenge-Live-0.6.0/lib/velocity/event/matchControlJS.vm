## Copyright (c) 2018 FIRST, Thomas Barnette, George Marchant, and Trey Woodlief. All rights reserved.
##
## Redistribution and use in source and binary forms, with or without modification,
## are permitted (subject to the limitations in the disclaimer below) provided that
## the following conditions are met:
##
## Redistributions of source code must retain the above copyright notice, this list
## of conditions and the following disclaimer.
##
## Redistributions in binary form must reproduce the above copyright notice, this
## list of conditions and the following disclaimer in the documentation and/or
## other materials provided with the distribution.
##
## Neither the name of FIRST nor the names of its contributors may be used to endorse or
## promote products derived from this software without specific prior written permission.
##
## NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
## LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
## ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
## FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
## DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
## CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
## OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
## OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##

##ONLY JS in this file. For pages that get complex, such as match control and gameDisplay, 
##we need to separate structure (HTML), function (JS), and appearance (CSS). No inline styling!

##After this file is mostly complete, we can see how much can be extracted from the velocity
##template an placed in a proper .js file. (Perhaps everythign except variable initialization)
//active match only if started
//nextMatch is loaded

var liveScoring = $liveScoring;
var externalRandom = $externalRandom;
var liveScoring = $liveScoring;
console.log(liveScoring+","+externalRandom);

var activeMatch = $activeMatch; //TODO should we calculate this locally from our schedule?
var loadedMatch = $activeMatch;
var activeMatchIndex = -1;
var loadedMatchIndex = -1;
var nextToLoad = $nextMatch;
var scheduleChangeListener;
var scoreUpdatePromise; //Only for active Match
var redInit = false;
var blueInit = false;
var matchTimerSpan;
var unsavedCountDiv;

var testLoaded = false;
var testActive = false;
var testMatches = [];

var editingMatch = -1;
var editingIndex = -1;
var editingRandom = -1;

var lastScheduleUpdate = -1;
var loadedReady = false; //set to true on init (NOT A SCHEDULE UPDATE, needs notificationfor each aliance to display who were waiting on?)

const STATE_UNLOADED = 0;
const STATE_LOADED = 1;
const STATE_PRE_RANDOM = 2;
const STATE_POST_RANDOM = 3;
const STATE_POST_RANDOM_INIT = 31; //Same as 
const STATE_RANDOM_SHOWN = 4;
const STATE_RANDOM_SHOWN_INIT = 41;
const STATE_WAIT_FOR_INIT = 5;
const STATE_READY = 6;
const STATE_IN_MATCH = 7;
const STATE_IN_MATCH_NO_NEXT = 8;
const STATE_NEXT_LOADED = 9;
const STATE_NEXT_RANDOMIZED = 10;
const STATE_ABORTED = 11;

const BTN_OFF = 0; //unclickable
const BTN_GOOD = 1; //green/blue, within standard flow
const BTN_WARN = 2; //yellow, backwards flow
const BTN_BAD = 3; //red, 2-step process, 


const STATE_LOADED_NO_LIVE = 12;
const STATE_PREVIEWED_NO_LIVE = 13;
const STATE_READY_NO_LIVE_NO_RANDOM = 14;
const STATE_ABORTED_NO_LIVE = 15;

const STATE_NO_AVAILABLE_MATCH = 99;


const MATCH_CONTROL_MAPPING = {
//  Stat  Load     Preview   Randomize Shw Rdm   Shw Match  Start

	99: [BTN_OFF,  BTN_OFF,  BTN_OFF,  BTN_OFF,  BTN_OFF,  BTN_OFF],
	0:  [BTN_GOOD, BTN_OFF,  BTN_OFF,  BTN_OFF,  BTN_OFF,  BTN_OFF], 
	1:  [BTN_OFF,  BTN_GOOD, BTN_GOOD, BTN_OFF,  BTN_OFF,  BTN_OFF],
	2:  [BTN_OFF,  BTN_WARN, BTN_GOOD, BTN_OFF,  BTN_OFF,  BTN_OFF],
	3:  [BTN_OFF,  BTN_WARN, BTN_BAD,  BTN_GOOD, BTN_GOOD, BTN_BAD],
	31: [BTN_OFF,  BTN_WARN, BTN_BAD,  BTN_GOOD, BTN_GOOD, BTN_GOOD],
	4:  [BTN_OFF,  BTN_WARN, BTN_BAD,  BTN_WARN, BTN_GOOD, BTN_BAD],
	41: [BTN_OFF,  BTN_WARN, BTN_BAD,  BTN_WARN, BTN_GOOD, BTN_GOOD],
	5:  [BTN_OFF,  BTN_WARN, BTN_BAD,  BTN_WARN, BTN_WARN, BTN_BAD],
	6:  [BTN_OFF,  BTN_WARN, BTN_BAD,  BTN_WARN, BTN_WARN, BTN_GOOD],
	7:  [BTN_GOOD, BTN_OFF,  BTN_OFF,  BTN_OFF,  BTN_OFF,  BTN_BAD],
	8:  [BTN_OFF,  BTN_OFF,  BTN_OFF,  BTN_OFF,  BTN_OFF,  BTN_BAD],
	9:  [BTN_OFF,  BTN_OFF,  BTN_GOOD, BTN_OFF,  BTN_OFF,  BTN_BAD],
	10: [BTN_OFF,  BTN_OFF,  BTN_BAD,  BTN_OFF,  BTN_OFF,  BTN_BAD],
	
	11: [BTN_OFF,  BTN_WARN, BTN_WARN, BTN_WARN, BTN_WARN, BTN_GOOD],
	
	12: [BTN_OFF,  BTN_GOOD, BTN_GOOD, BTN_OFF, BTN_GOOD, BTN_GOOD],
	13: [BTN_OFF,  BTN_WARN, BTN_GOOD, BTN_OFF, BTN_GOOD, BTN_GOOD],
	14: [BTN_OFF,  BTN_WARN, BTN_WARN, BTN_OFF, BTN_WARN, BTN_GOOD],
	15: [BTN_OFF,  BTN_WARN, BTN_WARN, BTN_WARN, BTN_WARN, BTN_GOOD]
}

var state = 0;
const CLASS_MAP = ["off", "good", "warn", "bad"];
function setState(newState){
	console.log("Setting state to: "+newState);
	var buttonStates = MATCH_CONTROL_MAPPING[newState];
	$("#loadButton").removeClass().addClass("matchControlButton "+CLASS_MAP[buttonStates[0]]);
	$("#previewButton").removeClass().addClass("matchControlButton "+CLASS_MAP[buttonStates[1]]);
	$("#randomizeButton").removeClass().addClass("matchControlButton "+CLASS_MAP[buttonStates[2]]);
	$(".manualRandom").each(function(index){
		$(this).removeClass().addClass("manualRandom "+CLASS_MAP[buttonStates[2]]);
	});
	
	
	$("#showRandomButton").removeClass().addClass("matchControlButton "+CLASS_MAP[buttonStates[3]]);
	$("#showMatchButton").removeClass().addClass("matchControlButton "+CLASS_MAP[buttonStates[4]]);
	$("#startButton").removeClass().addClass("matchControlButton "+CLASS_MAP[buttonStates[5]]).prop("title", buttonStates[5] == BTN_BAD ? "Match Not Initialized!" : "");
	
	$("#externalRandomCB").prop("checked", externalRandom);
	$("#liveScoreCB").prop("checked", liveScoring);
	
	state = newState;
}
function sec(x){
	if(x < 10){
		return "0" + x;
	}		
	return "" + x;
}

function setActiveMatchState(state){
	if(!testActive){
		schedule[activeMatchIndex].state = state;
		updateMatch(activeMatchIndex);
	} else{
		testMatches[activeMatchIndex].state = state;
		renderUnsaved();
	}
}

var timer = new Timer(250, 158, function(x){
	var time = "";
	var phase = "";
	//TODO update in schedule. Probably need activeIndex & loadedIndex
	if(x < 30){
		phase = "Autonomous";
		time = "0:" + sec(30 - x);
	} else if(x < 38){
		phase = "Transition";
		time = "0:0"+ (38-x);
		setActiveMatchState("DRIV-CTRL");
	} else if(x < 158){
		phase = "Driver-Controlled";
		var tele = 158 - x;
		time = Math.floor(tele / 60) + ":" + sec(tele % 60);		
	} else{
		phase = "Complete";
		time = "0:00";
		setActiveMatchState("REVIEW");
		if(!testActive){		
			unsavedMatches.push(schedule[activeMatchIndex]);
			renderUnsaved();
		} else{
			
		}
		
		renderUnsaved();
		var b = $("#activeBanner");
		b.html("Showing scores for previous match. Scores will clear at start of next match. To edit click <button class='niceButton' onclick='editActive()'>here</button>.");
		b.prop("hidden", false);
		
        $("#startButton").html("Start<br>Match");
        $("#startButton").attr("onclick", "start()");
        
        $(".toBtn").removeClass("off");
        $("#startSelection").removeClass("off");
        $("#startSelection").attr("title","");
        
		if(!liveScoring){
			console.log("Immediate Lockout for " + activeMatch);
			lockoutActive();
		}
        
		console.log(state);
		switch(state){
			case STATE_IN_MATCH:
				setState(STATE_UNLOADED);
				break;
			case STATE_IN_MATCH_NO_NEXT:
				setState(STATE_NO_AVAILABLE_MATCH);
				break;
			case STATE_NEXT_LOADED:
				setState(liveScoring ? STATE_LOADED : STATE_LOADED_NO_LIVE);
				break;
			case STATE_NEXT_RANDOMIZED:
				setState(redInit && blueInit ? STATE_POST_RANDOM_INIT : STATE_POST_RANDOM);
				break;			
		}
	}
	$("#activeTime").text( time + " ("+phase+")");
}, function(x){}, function(x){});

var toTimer = new Timer(100,300, function(x){
	
	var time  = toTimer.stopTimeSec - x;
	$("#activeName").text("Timeout");
	$("#activeTime").text(Math.floor(time / 60) + ":"+ Math.floor((time % 60) / 10) +""+(time % 60) % 10);
	if(time == 0){
		$("#allianceTOBtn").removeClass("off");
		$("#fieldTOBtn").removeClass("off");
	}
}, function(){/*getTimeoutTime to reset start*/})


console.log("Initial Values: "+activeMatch+","+loadedMatch+","+nextToLoad);

/*
*We need to keep a local copy of these. They need to respond to remote changes.
They generally should not be edited locally - updates should come from the 
schduleChangeListener. An exception is for when a match ends, add it to 
unsaved. 
*/
var schedule = [];
var unsavedMatches = [];

$( document ).ready(function() {
	getSchedule();
	matchTimerSpan = document.getElementById("activeMatchTime");
	unsavedCountDiv = document.getElementById("unsavedCount");
	setState(nextToLoad == -1 ? STATE_NO_AVAILABLE_MATCH : STATE_UNLOADED);//TODO init state based on state of current matches
	$("#scores_active_red").find("input").prop("disabled", true);
	$("#scores_active_blue").find("input").prop("disabled", true);
	
	switchTab("scheduleTab", document.getElementById('scheduleTabButton'));
	
    console.log( "ready!" );
});
function getScheduleHeader(){
	var bar = $("<div/>").addClass("scheduleItem").addClass("scheduleHeader");
	bar.append($("<div/>").addClass("scheduleMatchName").text("Match"));
	bar.append($("<div/>").addClass("scheduleMatchState").text("State"));
	bar.append($("<div/>").addClass("scheduleScore").text("Red Score"));
	bar.append($("<div/>").addClass("scheduleTeam").text("Red 1"));
	bar.append($("<div/>").addClass("scheduleTeam").text("Red 2"));
	bar.append($("<div/>").addClass("scheduleTeam").text("Red 3"));
	bar.append($("<div/>").addClass("scheduleTeam").text("Blue 1"));
	bar.append($("<div/>").addClass("scheduleTeam").text("Blue 2"));
	bar.append($("<div/>").addClass("scheduleTeam").text("Blue 3"));	
	bar.append($("<div/>").addClass("scheduleScore").text("Blue Score"));
	return bar;
}
function getScheduleItem(m, id){
	if(m.red.scores && typeof(m.red.scores) == "string"){
		m.red.scores = JSON.parse(m.red.scores);
	}
	if(m.blue.scores && typeof( m.blue.scores) == "string"){
		m.blue.scores = JSON.parse(m.blue.scores);
	}
	
	var canEdit = true;
	if(m.type == "ELIMS" && m.shortName.indexOf("S") >= 0){ //This is a semis match
		for(var i = 0; i < schedule.length; i++){
			if(schedule[i].shortName.indexOf("S") < 0 && schedule[i].state == "COMMITTED"){ //a finals match has been committed
				canEdit = false;
				break;
			}
		}
	}
	
	
	bar = $("<div/>").attr("id", id+"_"+m.number).addClass("scheduleItem");
	bar.append($("<div/>").addClass("scheduleMatchName").text(m.name));
	bar.append($("<div/>").addClass("scheduleMatchState").text(m.state));
	bar.append($("<div/>").addClass("scheduleScore").html(m.red.scores == undefined ? "&nbsp;" : m.red.scores.scoredPoints + (m.blue.scores == undefined ? 0 : m.blue.scores.penaltyPoints)));
	bar.append($("<div/>").addClass("scheduleTeam").text(m.red.team1));
	bar.append($("<div/>").addClass("scheduleTeam").text(m.red.team2));
	bar.append($("<div/>").addClass("scheduleTeam").html(m.red.team3 ? m.red.team3 : "&nbsp;"));
	bar.append($("<div/>").addClass("scheduleTeam").text(m.blue.team1));
	bar.append($("<div/>").addClass("scheduleTeam").text(m.blue.team2));
	bar.append($("<div/>").addClass("scheduleTeam").html(m.blue.team3 ? m.blue.team3 : "&nbsp;"));	
	bar.append($("<div/>").addClass("scheduleScore").html(m.blue.scores == undefined ? "&nbsp;" : m.blue.scores.scoredPoints + (m.red.scores == undefined ? 0 : m.red.scores.penaltyPoints)));
	var op1 = $("<div/>").addClass("scheduleOp scheduleOp1");
	var op2 = $("<div/>").addClass("scheduleOp scheduleOp2");
	var op3 = $("<div/>").addClass("scheduleOp scheduleOp3");
	
	if(canEdit && (m.state == "UNPLAYED" || m.state == "RANDOMIZED") && m.number > 0){
		op1.append($("<button/>").text("Play").attr("onclick","loadOOOMatch("+m.number+")"));
		op3.append($("<button/>").text("Enter Scores").attr("onclick", "enterUnplayedScores("+m.number+")"));
	} else if(canEdit && (m.state == "COMMITTED" || m.state == "SUBMITTED")){
		op1.append($("<button/>").text("Replay").attr("onclick", "popup('Replay Match?','This will overwrite any saved scores and data for this match',loadMatch.bind(null,"+m.number+", true))"));
	}
	if(m.state == "SUBMITTED" && liveScoring){
		op2.append($("<button/>").text("Commit").attr("onclick", "commit("+m.number+")"));
	}
	if(m.state == "COMMITTED"){
		op2.append($("<button/>").text("Post").attr("onclick", "post("+m.number+")"));
	}
	if(canEdit && (m.state == "COMMITTED" || m.state == "SUBMITTED")){
		op3.append($("<button/>").text(liveScoring || m.state == "COMMITTED" ? "Edit" : "Enter Scores").attr("onclick", "edit("+m.number+")"));
	}
	if(m.state == "REVIEW"){
		op3.append($("<button/>").text("View").attr("onclick", "view("+m.number+")"));
	}
	
	bar.append(op1);
	bar.append(op2);
	bar.append(op3);
	return bar;
}

function renderUnsaved(){
	content = $("#unsavedTab");
	content.empty();
	var bar = getScheduleHeader();
	content.append(bar);
	for(var i = 0; i < unsavedMatches.length;i++){	
		var m = unsavedMatches[i];
		content.append(getScheduleItem(m, "unsaved"));
	}
	$("#unsavedCount").html(unsavedMatches.length);
	$("#unsavedCount").prop("hidden", unsavedMatches.length <= 0);
}

function renderSchedule(){
	var content=$("#scheduleTab");
	content.empty();
	var bar = getScheduleHeader();
	content.append(bar);
	for(var i = 0; i < schedule.length;i++){	
		var m = schedule[i];
		content.append(getScheduleItem(m, "schedule"));
	}
	
	renderUnsaved();
}

function updateMatch(index){
	
	var num = schedule[index].number;
	var rowOld=$("#schedule_"+num);
	rowOld.empty();
	var row = getScheduleItem(schedule[index], "temp");
	rowOld.append(row.children());
	
	//TODO unsaved tab if exists $("#blah").length > 0
	var rowOld=$("#unsaved_"+num);
	if(rowOld){
		rowOld.empty();
		var row = getScheduleItem(schedule[index], "temp");
		rowOld.append(row.children());
	}
}

function getSchedule(){
	$.ajax({
        url: "./schedule/",
        type: "GET",
        success: function (data) {
            //we good
            //console.log(data);
            unsavedMatches = [];
			data = JSON.parse(data);
			lastScheduleUpdate = data.lastUpdate;
			schedule = data.schedule;
			for(var i = 0; i < schedule.length; i++){
				if(schedule[i].state == "REVIEW" || schedule[i].state == "SUBMITTED"){
					unsavedMatches.push(schedule[i]);
				}
			}
			renderSchedule();
			if(!scheduleChangeListener){
				listenForScheduleChange();
			}			
			calculateNextMatch();
			for(var i = schedule.length - 1; i >= 0; i--){
				if(schedule[i].state == "AUTO" || schedule[i].state == "TELEOP" || schedule[i].state == "DRIV-CTRL"){
					var before = Date.now();
					$.ajax({url: "./time/"+schedule[i].number+"/",
					    type: "GET",
						success: function (data) {
							//elapsed time in ms since the request was sent to the server
							var latency = Date.now() - before;
							//elapsed time since match start in ms from when server received this request
							var time = parseInt(data);
							timer.start(time + latency/2);
							
							var am = schedule[i];
							activeMatch = am.number;
							activeMatchIndex = i;
							setState(nextToLoad == -1 ? STATE_IN_MATCH_NO_NEXT : STATE_IN_MATCH);
				            $("#lastMatch").addClass("off");
				            
				            $("#activeName").text(am.name);
				            $("#activeRed").text("Red: "+am.red.team1+", "+am.red.team2+ (am.red.team3 ? (", "+am.red.team3) : ""))
				            $("#activeBlue").text("Blue: "+am.blue.team1+", "+am.blue.team2+ (am.blue.team3 ? (", "+am.blue.team3) : ""));
				            
				            $("#active_red_team1 .scoreTeamNumber").text(am.red.team1);
				            $("#active_red_team2 .scoreTeamNumber").text(am.red.team2);
				            $("#active_red_team3 .scoreTeamNumber").text(am.red.team3 ? am.red.team3 : 0);
				            $("#active_blue_team1 .scoreTeamNumber").text(am.blue.team1);
				            $("#active_blue_team2 .scoreTeamNumber").text(am.blue.team2);
				            $("#active_blue_team3 .scoreTeamNumber").text(am.blue.team3 ? am.blue.team3 : 0);
				            $("#activeBanner").prop("hidden", true);
				            
				            $("#startButton").html("Abort<br>Match");
				            $("#startButton").attr("onclick", "abort()");
				            
				            $("#activeMatchName").text(am.name);
				            
				            $(".toBtn").addClass("off");
				            if(liveScoring){
				            	liveScores(activeMatch, 1);
				            }
				        },
				        error: function (xhr, textStatus, errorThrown) {
				            console.log("Error Loading in-progress match");
				        }
				    });
				    break;
				}
			}
			
			if(schedule && schedule.length > 0 && schedule[0].type=="ELIMS"){
				$("#selectionTabBtn").prop("disabled", true);
				$("#selectionTabBtn").attr("title", "Alliance Selection Completed");
				//TODO disable Alliance selection for League Meets
			}
			
        },
        error: function (xhr, textStatus, errorThrown) {
            //ERROR HANDLING
            console.log("Error");
        }});
}
function updateInitIndicator(){
	$("#loadedRed").css("background-color", redInit ? "#00C800" : "transparent");
	$("#loadedBlue").css("background-color", blueInit ? "#00C800" : "transparent");
	if(redInit && blueInit){
		loadedReady = true;
		switch(state){
			case STATE_POST_RANDOM:
				setState(STATE_POST_RANDOM_INIT);
				break;
			case STATE_RANDOM_SHOWN:
				setState(STATE_RANDOM_SHOWN_INIT);
				break;
			case STATE_WAIT_FOR_INIT:
				setState(STATE_READY);
				break;
		}
	}
}

function listenForScheduleChange(){
	
	scheduleChangeListener = $.ajax({
        url: "./schedulechange/"+lastScheduleUpdate+"/",
        type: "GET",
        success: function (data) {
            //we good
            try{
	            console.log(data);
	            data = JSON.parse(data);
	            //if we got 5 and oldest is > 1 after what we last knew, need to re-get schedule.
	            if(data.length == 5 && data[5].index > lastScheduleUpate + 1){
	            	getSchedule();
	            	console.log("WARNING: WE MISSED SCHEDULE UPDATES! REFETCHING SCHEDULE");
	            	alert("WARNING: WE MISSED SCHEDULE UPDATES! CHECK YOUR CONNECTION & REFRESH THIS PAGE");
	            	//TODO THIS MIGHT BREAK OUR REFERENCES TO INDICES OF THE SCHEDULE IN OTHER PARTS OF PAGE
	            	//WE MIGHT JUST WANT TO FORCE PAGE REFRESH 
	            	return;
	            }
	            for(var i = 0; i < data.length; i++){
	            	var update = data[i]; 
		            switch(update.type){
		            	case "MATCH_INIT":
		            		if(update.params[0] < 0 && !testLoaded){
		            			continue;
		            		}
		            		if(update.params[0] == loadedMatch){
		            			redInit = update.params[1];
		            			blueInit = update.params[2];
		            			updateInitIndicator();
		            		}
		            		break;
		            
		            	case "REVIEW_SUBMITTED":
		            		//get match with same number;
		            		var i = 0;
		            		var theMatch;
		            		if(update.params[0] < 0){
		            			for(; i < testMatches.length; i++){
		            				if(testMatches[i].number == update.params[0]){
		            					theMatch = testMatches[i];
		            					break;
		            				}
		            			}
		            		} else{
			            		for(; i < schedule.length; i++){
			            			if(schedule[i].number == update.params[0]){	 
			            				theMatch = schedule[i];
			            				break;
			            			}
			            		}
		            		}
		            				           			
	        				theMatch.state = update.params[4] ? "SUBMITTED" : "REVIEW";
	        				if(update.params[1] == 0){ //red alliance
	        					theMatch.red.scores = update.params[2];
	        				} else {
	        					theMatch.blue.scores = update.params[2];
	        				}
	        				if(theMatch.number >= 0){
	        					updateMatch(i);
	        				} else{
	        					renderUnsaved();
	        				}
	        				var d = {
	    						blue: theMatch.blue.scores,
	    						red: theMatch.red.scores,
	    						number: update.params[0],
	    						random: update.params[5],
	    						redBreakdown: update.params[1] == 0 ? JSON.parse(update.params[3]) : null,
	    						blueBreakdown: update.params[1] == 1 ? JSON.parse(update.params[3]) : null,
	    						redTotal: update.params[6],
	    						blueTotal: update.params[7]
	    					};
	        				if(activeMatch == update.params[0]){
	        					//Update the fields in the active tab with the new data	            					
	        					updateScoreTab("active", d);
	        					if(update.params[4]){
	        						$("#lastMatch").removeClass("off");
	        					}
	        				}
	        				if(editingMatch == update.params[0]){
	        					lastEditObject = d;
	        					updateScoreTab("scores", d);
	  
	        					if(update.params[4]){
						            $("#cancelEditsBtn").prop("disabled", true);
						            $("#saveEditsBtn").prop("disabled", true);
						            $("#commitEditsBtn").prop("disabled", theMatch.state == "COMMITTED"); 
						            $("#postEditsBtn").prop("disabled", theMatch.state != "COMMITTED");   
						            
						            disableEditInputs(false);
					            	$("#scoresBanner1").prop("hidden", false);
					            	$("#scoresBanner2").prop("hidden", true); 
				            	}        					
	        				}
		            		break;
		            	case "MATCHES_CREATED":
		            		//matches are ALWAYS appended. 	
		            		for(var i = 0; i < update.params[0].length; i++){
		            			schedule.push(update.params[0][i]);	
		            		}
		            		renderSchedule();
		            		calculateNextMatch();
		            		switch(state){
		            			case STATE_IN_MATCH_NO_NEXT:
		            				setState(STATE_IN_MATCH);
		            				break;
		            			case STATE_NO_AVAILABLE_MATCH:
		            				setState(STATE_UNLOADED);
		            				break;
		            		}
		            		break;
		            	case "MATCHES_CANCELLED":
		            		console.log(update.params[0]);
		            		for(var i = 0; i < update.params[0].length; i++){
		            			
		            			var num = update.params[0][i];
		            			console.log("Cancelling match " +num);
		            			var index = -1;
		            			for(index = 0; index < schedule.length; index++){
		            				if(schedule[index].number == num){
		            					break;
		            				}
		            			}
		            			
		            			if(index > -1 && index < schedule.length){
		            				//remove the match.
		            				if(activeMatch == num && !testActive){
		            					alert("The active match has been cancelled! Please abort it and refresh this page. (F5)");
			            			}
			            			if(loadedMatch == num && !testLoaded){
			            				alert("The loaded match has been cancelled! Please refresh this page. (F5)");
			            			}
		            				schedule.splice(index,1);
		            				calculateNextMatch();
		            			}
		            		}
		            		renderSchedule();
		            		break;
		            			
		            }
	            }
	            lastScheduleUpdate = data[data.length-1].index;
            	listenForScheduleChange();
            }catch(ex){
            	setTimeout(listenForScheduleChange, 1000);
            }
        },
        error: function (xhr, textStatus, errorThrown) {
            //ERROR HANDLING
            console.log("Error");
            setTimeout(listenForScheduleChange, 1000);
        }});
}

//Run to verify only (ie we dont already know )
function getInitStatus(callback){
	if(loadedMatch < 0 && !testLoaded){
		return;
	}
	if(!liveScoring){
		redInit = true;
		blueInit = true;
		loadedReady = true;
		updateInitIndicator();	
		if(callback){
			callback(true);
		}
		return;
	}
	$.ajax({
        url: "./init/"+loadedMatch+"/",
        type: "GET",
        success: function (data) {
            var status = JSON.parse(data);
            //color the background green
            redInit = status.red;
            blueInit = status.blue;
            loadedReady = redInit && blueInit;
            updateInitIndicator();
            if(callback){
            	callback(true);
            }
        },
        error: function (xhr, textStatus, errorThrown) {
            //ERROR HANDLING
            console.log("Error");
            if(callback){
            	callback(false);
            }
        }});
}

//If no next match, try again after the next schedule update (IE match committed)
//This should only be used if it could not be determined from our local variables
function getNextMatchNumber(){
	$.ajax({
        url: "./nextmatch/",
        type: "GET",
        success: function (data) {
            //we good
            console.log("we good");
            //nextToLoad = data?
        },
        error: function (xhr, textStatus, errorThrown) {
            //ERROR HANDLING
            console.log("Error");
        }});

}

function load(){
	loadMatch(nextToLoad);
}

function calculateNextMatch(){
	var nextIndex = loadedMatchIndex + 1; 
    while(nextIndex < schedule.length && schedule[nextIndex].state != "UNPLAYED"){
    	nextIndex++;
    }
    if(nextIndex >= schedule.length){
    	nextIndex = 0;
    	while(nextIndex < loadedMatchIndex && schedule[nextIndex].state != "UNPLAYED" ){
    		nextIndex++;
    	}
    	if(nextIndex >= loadedMatchIndex){
    		nextIndex = -2;
    	}
    }
    if(nextIndex >= 0){
    	nextToLoad = schedule[nextIndex].number;
    } else{
    	nextToLoad = -1;
    }
    console.log("Next Match = " +nextToLoad);
}

function loadMatch(match, replay) {
	$.ajax({
        url: "./load/" + match +"/",
        type: "POST",
        data: '',
        success: function (data) {
            //we good
            testLoaded = false;
            loadedMatch = match;
            loadedReady = false; 
            var matchObj;
            for(var i = 0; i < schedule.length; i++){
				if(schedule[i].number == loadedMatch){
					loadedMatchIndex = i;
					matchObj = schedule[i];
					break;
				}
			}
            console.log("Loaded match "+loadedMatch + "(index "+loadedMatchIndex+")");
            //Determine next match from our local schedule var.
            calculateNextMatch();
            $("#loadedName").text(matchObj.name);
            $("#loadedTime").text("2:30 (Not Started)");
            $("#loadedRed").text("Red: "+matchObj.red.team1+", "+matchObj.red.team2+ (matchObj.red.team3 ? (", "+matchObj.red.team3) : ""));
            $("#loadedBlue").text("Blue: "+matchObj.blue.team1+", "+matchObj.blue.team2+ (matchObj.blue.team3 ? (", "+matchObj.blue.team3) : ""));
            redInit = false;
            blueInit = false;
            updateInitIndicator();
            
            updateMatch(loadedMatchIndex);
            renderUnsaved();
            document.getElementById("loadButton").innerHTML = "Load Next <br>Match";
            var r = schedule[i].randomization > 0;
            
            if(!liveScoring){
            	redInit = true;
				blueInit = true;
				loadedReady = true;
				updateInitIndicator();	
            }
            if(!replay && r){
            	getInitStatus(function(){
            		setState(state == STATE_IN_MATCH ? STATE_NEXT_RANDOMIZED : (loadedReady ? STATE_POST_RANDOM_INIT : STATE_POST_RANDOM));
            	});
            } else{
            	setState(state == STATE_IN_MATCH ? STATE_NEXT_LOADED : (liveScoring ? STATE_LOADED : STATE_LOADED_NO_LIVE));          
            }
            
                     
        },
        error: function (xhr, textStatus, errorThrown) {
            //ERROR HANDLING
            console.log("Error");
        }});
}
function showSponsors() {
		$.ajax({url: "./sponsors/",
	    type: "POST",
		success: function (data) {
			//show that we are showing sponsors?
        },
        error: function (xhr, textStatus, errorThrown) {
            console.log("Error Showing Sponsors");
        }});
}
function preview(){
	$.ajax({url: "./preview/"+loadedMatch+"/",
	    type: "POST",
		success: function (data) {
			//Update control state
			if(state == STATE_LOADED){
				setState(STATE_PRE_RANDOM);
			} else if(state == STATE_LOADED_NO_LIVE){
        		setState(STATE_PREVIEWED_NO_LIVE);
			}
        },
        error: function (xhr, textStatus, errorThrown) {
            //ERROR HANDLING
            console.log("Error Showing Preview");
        }});
}
//TODO add param to this that checks if confirmed. If not in BTN_BAD state, dont care, if we are that needs to be true
function randomize(confirmed, val) {
	if(loadedMatch < 0 & !testLoaded){
		return;
	}
	if(!confirmed && $("#randomizeButton").hasClass("bad")){
		popup("Re-Randomize?", 
		"Referees may need to refresh their pages.<br>Remember, per &lt;GS1&gt; a team that has touched or interacted with their <i>Robot</i> or <i>Driver Stations</i> after randomization are not eligible to earn the <e>Sample Score</e>.", 
		randomize.bind(null, true, val));
		return;
	}
	
	$.ajax({
        url: "./randomize/"+loadedMatch+"/",
        type: "POST",
        data: {val:val?val:-1},
        success: function (data) {
		    if(!testLoaded){
				schedule[loadedMatchIndex].state = "RANDOMIZED";
				schedule[loadedMatchIndex].randomization = parseInt(data);
				updateMatch(loadedMatchIndex);
			} else{
				testMatches[loadedMatchIndex].state = "RANDOMIZED";
				testMatches[loadedMatchIndex].randomization = parseInt(data);
				renderUnsaved();
			}
        
            //the match randomization is returned
            console.log("randomized: "+data);
            switch(state){
            	case STATE_PRE_RANDOM:
            	case STATE_LOADED_NO_LIVE:
            	case STATE_PREVIEWED_NO_LIVE:
            	case STATE_LOADED:
            	case STATE_READY_NO_LIVE_NO_RANDOM:
            		setState(loadedReady ? STATE_POST_RANDOM_INIT : STATE_POST_RANDOM);
            		break;
            	//TODO for the following states, should it set to RANDOM_SHOWN IFF we have displayed this match's preview or previous random?
            	case STATE_POST_RANDOM:
            	case STATE_RANDOM_SHOWN:
            	case STATE_WAIT_FOR_INIT:
            		setState(STATE_POST_RANDOM);
            		break;
            	case STATE_POST_RANDOM_INIT:
            	case STATE_RANDOM_SHOWN_INIT:
            	case STATE_READY:
            		setState(STATE_POST_RANDOM_INIT);
            		break;
            	case STATE_NEXT_LOADED:
            		setState(STATE_NEXT_RANDOMIZED);
            		break;
            }
        },
        error: function (xhr, textStatus, errorThrown) {
            //ERROR HANDLING
            console.log("Error");
        }});
}

function showRandom(){
	$.ajax({
        url: "./showrandom/"+loadedMatch+"/",
        type: "POST",
        data: '',
        success: function(data){
        	//Update control state
        	if(state == STATE_POST_RANDOM){
        		setState(STATE_RANDOM_SHOWN);
        	} else if(state == STATE_POST_RANDOM_INIT){
        		setState(STATE_RANDOM_SHOWN_INIT);
        	}
        }
        });
}

function showMatch(){
	$.ajax({
        url: "./showmatch/"+loadedMatch+"/",
        type: "POST",
        data: '',
        success: function(data){
        	switch(state){
        		case STATE_RANDOM_SHOWN:
        		case STATE_POST_RANDOM:
	        		setState(STATE_WAIT_FOR_INIT);
	        		break;
        		case STATE_RANDOM_SHOWN_INIT:
        		case STATE_POST_RANDOM_INIT:
        			setState(STATE_READY);
        			break;	
        		case STATE_LOADED_NO_LIVE:
        		case STATE_PREVIEWED_NO_LIVE:
        			setState(STATE_READY_NO_LIVE_NO_RANDOM);
        			break;
        	}
        }
    });
}

function start(confirmed){
	if(loadedMatch < 0 && !testLoaded){
		return;
	}
		$.ajax({
        url: "./start/"+loadedMatch+"/",
        type: "POST",
        data: '',
        success: function (data) {
            //start local timer
            console.log("we good");
            activeMatch = loadedMatch;
            activeMatchIndex = loadedMatchIndex;
            var am = null;
            timer.start();
            loadedMatch = -1;
            loadedMatchIndex = -1;
            testActive = testLoaded;
            testLoaded = false;
            setActiveMatchState("AUTO");
            if(!testActive){
	            am = schedule[activeMatchIndex];
            }else{
            	//Test match, iterate through unsaved matches to find
            	am = testMatches[activeMatchIndex];   
            }
            
        	if(am == null){
        		console.log("NULL ACTIVE MATCH FROM START!");
        		
        	} 
            setState(nextToLoad == -1 ? STATE_IN_MATCH_NO_NEXT : STATE_IN_MATCH);
            $("#lastMatch").addClass("off");
            
            $("#activeName").text($("#loadedName").text());
            $("#activeRed").text($("#loadedRed").text())
            $("#activeBlue").text($("#loadedBlue").text());
            $("#activeTime").text("0:30 (Autonomous)");
            $("#loadedName").text("");
            $("#loadedTime").text("");
            $("#loadedRed").text("");
            $("#loadedBlue").text("");
            redInit = false;
            blueInit = false;
            updateInitIndicator();
            $("#activeTab .scoreTeamNumber").removeClass("card");
            $("#active_red_team1 .scoreTeamNumber").text(am.red.team1);
            $("#active_red_team2 .scoreTeamNumber").text(am.red.team2);
            $("#active_red_team3 .scoreTeamNumber").text(am.red.team3 ? am.red.team3 : 0);
            $("#active_red_team3").prop("hidden", !am.red.team3 || am.red.team3 == 0);
            $("#active_blue_team1 .scoreTeamNumber").text(am.blue.team1);
            $("#active_blue_team2 .scoreTeamNumber").text(am.blue.team2);
            $("#active_blue_team3 .scoreTeamNumber").text(am.blue.team3 ? am.blue.team3 : 0); 
            $("#active_blue_team3").prop("hidden", !am.blue.team3 || am.blue.team3 == 0);
            
            $("#activeBanner").prop("hidden", true);
            
            $("#startButton").html("Abort<br>Match");
            $("#startButton").attr("onclick", "abort()");
            
            $("#activeMatchName").text(am.name);
            
            
        	$("#startSelection").addClass("off");
        	$("#startSelection").attr("title","Match in Progress!");
            
            $(".toBtn").addClass("off");
            
            if(editingMatch == activeMatch){
            	$("#scoreEditTabBtn").prop("disabled", true);
            	if(liveScoring){
            		$("#activeTabBtn").click();
            	} else{
            		$("#scheduleTabButton").click();
            	}
            }
            
            if(liveScoring){
            	liveScores(activeMatch, 1);
            }
        },
        error: function (xhr, textStatus, errorThrown) {
            //ERROR HANDLING
            console.log("Error");
        }});
}

function abort(confirmed){
	if(!confirmed){
		popup("Abort Match?", "This will reset the current match and discard all scores. Referees will need to refresh their devices.", abort.bind(null, true));
		return;
	}
	$.ajax({
        url: "./abort/"+activeMatch+"/",
        type: "POST",
        data: '',
        success: function (data) {
        
            setActiveMatchState("RANDOMIZED");
            
            if(loadedMatch != -1 || (testLoaded && loadedMatch < 0)){
            	nextIndex = loadedMatchIndex;
            	nextToLoad = loadedMatch;
            }
            
        	loadedMatch = activeMatch;
            loadedMatchIndex = activeMatchIndex;
            testLoaded = testActive;
            activeMatch = -1;
            activeMatchIndex = -1;
            testActive = false;
            if(scoreUpdatePromise){
				scoreUpdatePromise.abort();
			}
            
            timer.reset();
            $("#loadedName").text($("#activeName").text());
            $("#loadedRed").text($("#activeRed").text())
            $("#loadedBlue").text($("#activeBlue").text());
            $("#loadedTime").text("2:30 (Aborted)");
            $("#activeName").text("");
            $("#activeTime").text("");
            $("#activeRed").text("");
            $("#activeBlue").text("");
            
             $("#activeBanner").prop("hidden", false);
            
            var am = null;
            setState(liveScoring ? STATE_WAIT_FOR_INIT : STATE_READY);
        	$("#startButton").html("Start<br>Match");
        	$("#startButton").attr("onclick", "start()"); 
        	
        	$(".toBtn").removeClass("off");
        },
        error: function (xhr, textStatus, errorThrown) {
            //ERROR HANDLING
            console.log("Error");
        }
    });
}

function setCommitted(n){
	if(n < 0){
		for(var i = 0; i < testMatches.length; i++){
			if(testMatches[i].number == n){
				testMatches[i].state = "COMMITTED";
				break;
			}
		}
	} else{
		for(var i = 0; i < schedule.length; i++){
			if(schedule[i].number == n){
				schedule[i].state = "COMMITTED";
				updateMatch(i);
				break;
			}
		}
	}
	for(var i = 0; i < unsavedMatches.length; i++){
		if(unsavedMatches[i].number == n){
			unsavedMatches.splice(i, 1);
			renderUnsaved();
			break;
		}
	}
	calculateNextMatch();
	if(nextToLoad == -1){
		//if in unloaded state, 
		switch(state){
			case STATE_UNLOADED:
				setState(STATE_NO_AVAILABLE_MATCH);
				break;
			case STATE_IN_MATCH:
				setState(STATE_IN_MATCH_NO_NEXT);
				break;
		}
	}
	
}
function commitFailedAlert(){
	alert("Failed to commit scores! Data may not be saved. "+
        	"Make sure your connection to the server is OK, and try again. "+
        	"If you continue to see this message, contact your FTA or FIRST Support."+
        	" If using live scoring, do not restart the server without saving a screenshot of the scores for this match.");
}
function verifyCommit(data, num){
	var theMatch;
	var i = 0;
	if(num < 0){
		for(; i < testMatches.length; i++){
			if(testMatches[i].number == num){
				theMatch = testMatches[i];
				break;
			}
		}
	} else{
		for(; i < schedule.length; i++){
			if(schedule[i].number == num){	 
				theMatch = schedule[i];
				break;
			}
		}
	}
	var warning = false;
	try {
		warning = JSON.stringify(theMatch.red.scores) != JSON.stringify(JSON.parse(data.red)) || JSON.stringify(theMatch.blue.scores) != JSON.stringify(JSON.parse(data.blue));
	} catch(error) {
		warning = true;
	}           			
	if(warning){
		alert("Warning! The scores saved to the database may not match the scores shown here. Edit the match and verify the scores are correct and try again. If you continue to see the message contact FIRST support.");
		return false;
	}		
	return true;
}

function commit(num, onComplete){
//save any locally edited data before this.
	$.ajax({
        url: "./commit/"+num+"/",
        type: "POST",
        data: "",
        success: function(d){
    		
    		var data = JSON.parse(d);
    		verifyCommit(data, num);
    		//Note, we cannot return because the backend has moved the match into committed state. At this point the user should
    		//use the standard edit operations to check the match values. 
    		
    		setCommitted(num);
    		if(num == activeMatch){
    			$("#lastMatch").addClass("off");
    		}
    		if(onComplete){
    			onComplete();
    		}
        },error: function (xhr, textStatus, errorThrown) {
        	console.log(textStatus);
        	commitFailedAlert();
        }
        });
}

function commitAndPostLast(){
	//Not allowed if match in progress
	$.ajax({
        url: "./commitandpost/"+activeMatch+"/",
        type: "POST",
        data: '',
        success: function(d){        	
        
        	var data = JSON.parse(d);
    		verifyCommit(data, activeMatch);
    		        
    		setCommitted(activeMatch);
    		$("#lastMatch").addClass("off");
    		
        },
        error: function (xhr, textStatus, errorThrown) {
        	console.log(textStatus);
        	commitFailedAlert();
        }
        });
}
function post(num){
	$.ajax({
        url: "./results/"+num+"/",
        type: "POST",
        data: "",
        success: function(d){
        }
        });
}
var popupConfirm = null;

function popupCancel(){
	$("#popupLayer").hide();
}

function popupYes(){
	$("#popupLayer").hide();
	if(popupConfirm){
		popupConfirm();
	}
}

//This weirdness is to appease the Edge Gods.
function popup(title, body, cb){
	$("#popupLayer").toggle();
	$("#popupHeader").html(title);
	$("#popupBody").html(body);
	var count = 0;
	
	while(!$("#popup").is(":visible") && count < 10){
		$("#popup").hide();
		$("#popup").show();
		count++;
	}
	if(count > 0){
		console.log("popup render count: "+count);
	}
	if(!$("#popup").is(":visible")){
		alert("We have detected your browser is not rendering properly. Consder using a different browser.");
	}
	popupConfirm = cb;
}


function switchTab(dest, button){
	$(".selectedTab").removeClass("selectedTab");
	$(button).addClass("selectedTab");
	var tabs = document.getElementsByClassName("tabContent");
	for(var i = 0; i < tabs.length; i++){
		tabs[i].classList.remove("activeTab");
		if(tabs[i].id==dest){
			tabs[i].classList.add("activeTab");
		}		
	}
}
function updateScoreTab(tab, data){
	console.log(data);
	
	for( var a = 0; a < 2; a++){
		var as = a == 0 ? 'red' : 'blue';
		var os = a == 0 ? 'blue' : 'red';
		var obj = a == 0 ? data.red : data.blue;
		
		$("#"+tab+"_"+as+"_team1 .scoreNoShowDiv input").prop("checked", obj.noshow1);
		$("#"+tab+"_"+as+"_team2 .scoreNoShowDiv input").prop("checked", obj.noshow2);
		$("#"+tab+"_"+as+"_team3 .scoreNoShowDiv input").prop("checked", obj.noshow3);
		
		$("#"+tab+"_"+as+"_team1 .scoreRCDiv input").prop("checked", obj.card1 >= 2);
		$("#"+tab+"_"+as+"_team1 .scoreYCDiv input").prop("checked", obj.card1 == 1 || obj.card1 == 3);
		$("#"+tab+"_"+as+"_team2 .scoreRCDiv input").prop("checked", obj.card2 >= 2);
		$("#"+tab+"_"+as+"_team2 .scoreYCDiv input").prop("checked", obj.card2 == 1 || obj.card2 == 3);
		$("#"+tab+"_"+as+"_team3 .scoreRCDiv input").prop("checked", obj.card1 >= 2);
		$("#"+tab+"_"+as+"_team3 .scoreYCDiv input").prop("checked", obj.card1 == 1 || obj.card1 == 3);
		
		$("#"+tab+"_"+as+"_robot1Landed").prop("checked", obj.landed1);
		$("#"+tab+"_"+as+"_robot2Landed").prop("checked", obj.landed2);
		$("#"+tab+"_"+as+"_robot1Claimed").prop("checked", obj.claimed1);
		$("#"+tab+"_"+as+"_robot2Claimed").prop("checked", obj.claimed2);
		$("#"+tab+"_"+as+"_robot1AutoParked").prop("checked", obj.autoParking1);
		$("#"+tab+"_"+as+"_robot2AutoParked").prop("checked", obj.autoParking2);
		
		//Take randomization, && field state, and them map the positions to the static paper positions
		if(data.random == -1){ //Random1  matches paper, so if using paper (& thus no random), match to 1.
			data.random = 1;
		}
		var map = [0b100, 0b010, 0b001, 0b001, 0b010, 0b100];
		for(var x = 0; x < 2; x++){
			var sf = obj.sampleFieldState;
			if(x == 0){
				sf >>= 3;
			}
			var goldOn = sf & map[data.random - 1];
			var silver1On = sf & ((data.random == 1 || data.random == 6) ? 0b010 : 0b100);
			var silver2On = sf & ((data.random == 3 || data.random == 4) ? 0b010 : 0b001);
			$("#"+tab+"_"+as+"_sf"+(x+1)+"GoldOn").prop("checked", goldOn);
			$("#"+tab+"_"+as+"_sf"+(x+1)+"GoldOff").prop("checked", !goldOn);
			$("#"+tab+"_"+as+"_sf"+(x+1)+"Silver1On").prop("checked", silver1On);
			$("#"+tab+"_"+as+"_sf"+(x+1)+"Silver1Off").prop("checked", !silver1On);
			$("#"+tab+"_"+as+"_sf"+(x+1)+"Silver2On").prop("checked", silver2On);
			$("#"+tab+"_"+as+"_sf"+(x+1)+"Silver2Off").prop("checked", !silver2On);
		}
		$("#"+tab+"_"+as+"_gold").val(obj.gold);
		$("#"+tab+"_"+as+"_silver").val(obj.silver);
		$("#"+tab+"_"+as+"_depot").val(obj.depot);
		
		$("#"+tab+"_"+as+"_CraterOut1").prop("checked", obj.endParked1 == 0);
		$("#"+tab+"_"+as+"_CraterPartial1").prop("checked", obj.endParked1 == 1);
		$("#"+tab+"_"+as+"_CraterIn1").prop("checked", obj.endParked1 == 2);	
		
		$("#"+tab+"_"+as+"_CraterOut2").prop("checked", obj.endParked2 == 0);
		$("#"+tab+"_"+as+"_CraterPartial2").prop("checked", obj.endParked2 == 1);
		$("#"+tab+"_"+as+"_CraterIn2").prop("checked", obj.endParked2 == 2);	
		
		$("#"+tab+"_"+as+"_Latched1").prop("checked", obj.latched1);
		$("#"+tab+"_"+as+"_Latched2").prop("checked", obj.latched2);
		
		
		$("#"+tab+"_"+as+"_major").val(obj.major);
		$("#"+tab+"_"+as+"_minor").val(obj.minor);
		
		$("#"+tab+"_"+as+"Adjust").val(obj.adjust);
		
		
		var other = a == 0 ? data.blue : data.red;
		
		$("#"+tab+"_"+as+"FoulScore").text(other.penaltyPoints);		
		
		
		obj = a == 0 ? data.redBreakdown : data.blueBreakdown;
		if(!obj){
			continue;
		}
		
		
		$("#"+tab+"_"+as+"AutoScore").text(obj.autoParkingPoints + obj.claimedPoints + obj.samplingPoints + obj.landedPoints);
		$("#"+tab+"_"+as+"LandingPoints").text(obj.landedPoints);
		$("#"+tab+"_"+as+"SamplingPoints").text(obj.samplingPoints);
		$("#"+tab+"_"+as+"ClaimingPoints").text(obj.claimedPoints);
		$("#"+tab+"_"+as+"AutoParkingPoints").text(obj.autoParkingPoints);
		
		$("#"+tab+"_"+as+"DepotPoints").text(obj.depotPoints);
		$("#"+tab+"_"+as+"GoldPoints").text(obj.goldPoints);
		$("#"+tab+"_"+as+"SilverPoints").text(obj.silverPoints);		
		$("#"+tab+"_"+as+"MineralScore").text(obj.depotPoints + obj.goldPoints + obj.silverPoints);
		
		$("#"+tab+"_"+as+"ParkingScore").text(obj.endParkingPoints);
		$("#"+tab+"_"+as+"LatchingPoints").text(obj.latchedPoints);
		$("#"+tab+"_"+as+"EndGameScore").text(obj.endParkingPoints + obj.latchedPoints);
				
	}
	$(".adjust").prop("hidden", data.type != "ELIMS" || data.red.card1 < 2 || data.blue.card1 < 2);
	
	$("#"+tab+"_red_total").text(data.redTotal);
	$("#"+tab+"_blue_total").text(data.blueTotal);
	
	if(data.redCardCarries1){
		var r1 = $("#"+tab+"_red_team1 .scoreTeamNumber");
		var r2 = $("#"+tab+"_red_team2 .scoreTeamNumber");
		var r3 = $("#"+tab+"_red_team3 .scoreTeamNumber");
		if(data.redCardCarries1.length > 0){
			r1.addClass("card");
			r3.addClass("card");
			r1.attr("title", "Earned cards in "+data.redCardCarries1);
			r3.attr("title", "Earned cards in "+data.redCardCarries1);
		} else{
			r1.removeClass("card");
			r3.removeClass("card");
			r1.attr("title", "");
			r3.attr("title", "");
		}
		if(data.redCardCarries2.length > 0){
			r2.addClass("card");
			r2.attr("title", "Earned cards in "+data.redCardCarries2);
		} else{
			r1.attr("title", "");
			r2.removeClass("card");
		}
		
		var b1 = $("#"+tab+"_blue_team1 .scoreTeamNumber");
		var b2 = $("#"+tab+"_blue_team2 .scoreTeamNumber");
		var b3 = $("#"+tab+"_blue_team3 .scoreTeamNumber");
		if(data.blueCardCarries1.length > 0){
			b1.addClass("card");
			b3.addClass("card");
			b1.attr("title", "Earned cards in "+data.blueCardCarries1);
			b3.attr("title", "Earned cards in "+data.blueCardCarries1);
		} else{
			b1.removeClass("card");
			b3.removeClass("card");
			b1.attr("title", "");
			b3.attr("title", "");
		}
		if(data.blueCardCarries2.length > 0){
			b2.addClass("card");
			b2.attr("title", "Earned cards in "+data.blueCardCarries2);
		}else{
			b2.removeClass("card");
			b2.attr("title", "");
		}
	}
}

function liveScores(match, to){
	if(match < 0 && !testActive){
		return;
	}
	if(scoreUpdatePromise){
		scoreUpdatePromise.abort();
	}
	scoreUpdatePromise = $.ajax({
        url: "../display/scoreupdate/"+match+"/" + (to ? ("?to="+to+"&random=$random") : "?random=$random"),
        type: "GET",        
        success: function (data) {
       		try{
	            var d = JSON.parse(data);
	            d.red = JSON.parse(d.red);
	            d.blue = JSON.parse(d.blue);
	            d.redBreakdown = JSON.parse(d.redBreakdown);
	            d.blueBreakdown = JSON.parse(d.blueBreakdown);
	            updateScoreTab("active", d);
	            (testActive ? testMatches : schedule)[activeMatchIndex].red.scores = d.red;
	            (testActive ? testMatches : schedule)[activeMatchIndex].blue.scores = d.blue;
	            if(d.liveScoringComplete){
	            	return;
	            }
            	liveScores(match);
            }catch(er){
            	setTimeout(liveScores.bind(null, match), 1000);
            }
        },
        error: function (xhr, textStatus, errorThrown) {
        	if(textStatus == "abort"){
        		console.log("Score updates aborted for "+match);
        		return;
        	}
			console.log("ERROR "+textStatus);
			console.log(xhr);
			setTimeout(liveScores.bind(null, match), 1000);
        }});
}

function edit(num){
	//I need to get the scores object from the server (to get breakdown).
	//Use calculateScore endpoint
	var am;
	if(num < 0){
		for(var i = 0; i < testMatches.length; i++){
			if(testMatches[i].number == num){
				am = testMatches[i];
				editingIndex = i;
				editingMatch = num;
				break;
			}
		}
	} else{
		for(var i = 0; i < schedule.length; i++){
			if(schedule[i].number == num){
				am=schedule[i];
				editingIndex = i;
				editingMatch = num;
				break;
			}
		}
	}
	var obj = {
		red:JSON.stringify(am.red.scores),
		blue:JSON.stringify(am.blue.scores)
	}
	$.ajax({
        url: "./unsavededit/"+num+"/",
        type: "POST",   
        data: obj,     
        success: function (data) {
        	var d = JSON.parse(data);
            d.red = JSON.parse(d.red);
            d.blue = JSON.parse(d.blue);
            d.redBreakdown = JSON.parse(d.redBreakdown);
            d.blueBreakdown = JSON.parse(d.blueBreakdown);
            editingRandom = d.random;
            
            if(!am.red.scores || !am.blue.scores){
            	am.red.scores = d.red;
            	am.blue.scores = d.red;
            	am.randomization = d.random; 
            }
            
            updateScoreTab("scores", d);
            
            $("#scoreTab .scoreTeamNumber").removeClass("card");
            
            
            //TODO REMOVE CARDS FROM HERE. They are handled by updateSCoreTab
            var r1 = $("#scores_red_team1 .scoreTeamNumber");
            r1.text(am.red.team1);
            if(d.redCardCarries1.length > 0){
            	r1.addClass("card");
            }
            var r2 = $("#scores_red_team2 .scoreTeamNumber");
            r2.text(am.red.team2);
            if(d.redCardCarries2.length > 0){
            	r2.addClass("card");
            }
            var r3 = $("#scores_red_team3 .scoreTeamNumber");
            r3.text(am.red.team3 ? am.red.team3 : 0);
            if(d.redCardCarries1.length > 0){
            	r3.addClass("card");
            }
            var b1 = $("#scores_blue_team1 .scoreTeamNumber");
            b1.text(am.blue.team1);
            if(d.blueCardCarries1.length > 0){
            	b1.addClass("card");
            }
            var b2 = $("#scores_blue_team2 .scoreTeamNumber");
            b2.text(am.blue.team2);
            if(d.blueCardCarries2.length > 0){
            	b2.addClass("card");
            }
            var b3 = $("#scores_blue_team3 .scoreTeamNumber");
            b3.text(am.blue.team3 ? am.blue.team3 : 0);
            if(d.blueCardCarries1.length > 0){
            	b3.addClass("card");
            }
            
            
            $("#scores_red_team3").prop("hidden", !am.red.team3 || am.red.team3 == 0);            
            $("#scores_blue_team3").prop("hidden", !am.blue.team3 || am.blue.team3 == 0);
            
            $("#scoresMatchName").text(am.name);
            $("#cancelEditsBtn").prop("disabled", true);
            $("#saveEditsBtn").prop("disabled", true);
            $("#commitEditsBtn").prop("disabled", am.state == "COMMITTED"); 
            $("#postEditsBtn").prop("disabled", am.state != "COMMITTED");
             
            lastEditObject = {
            	red: d.red,
            	blue:d.blue
            }
            
            //If match has not ben submitted, disable all inputs.
            //This does not disable fr unplayed match (for paper entry ~ although still should have played the match??)
            if(am.state == "AUTO" || am.state == "TELEOP" || am.state == "REVIEW" ){ //TODO only enforce this if live scoring is enabled. 
            	disableEditInputs(true);
            	$("#scoresBanner1").prop("hidden", true);
            	$("#scoresBanner2").prop("hidden", false);
            } else{
            	disableEditInputs(false);
            	$("#scoresBanner1").prop("hidden", false);
            	$("#scoresBanner2").prop("hidden", true);
            }
            
            
			switchTab("scoreTab", document.getElementById('scoreEditTabBtn'));
			$("#scoreEditTabBtn").prop("disabled", false);
        },
        error: function (xhr, textStatus, errorThrown) {
			console.log("ERROR "+textStatus);
			console.log(xhr);
        }});
	
}
function view(num){
	edit(num);
}

function getScoreObject(){
	var obj = {red:null, blue:null};
	if(editingRandom < 1){
		editingRandom = 1;
	}
	for(var a = 0; a < 2; a++){
		var as = a == 0 ? "red" : "blue";
		var old = null;
		if(editingMatch < 0){
			old = testMatches[editingIndex][as].scores;
		} else{
			old = schedule[editingIndex][as].scores;
		}
		var sf = 0;
		
		sf |= $("#scores_"+as+"_sf2GoldOn").prop("checked") ? (editingRandom == 1 || editingRandom == 6 ? 0b000100 : (editingRandom == 2 || editingRandom == 5 ? 0b000010 : 0b000001)) : 0;
		sf |= $("#scores_"+as+"_sf1GoldOn").prop("checked") ? (editingRandom == 1 || editingRandom == 6 ? 0b100000 : (editingRandom == 2 || editingRandom == 5 ? 0b010000 : 0b001000)) : 0;
		sf |= $("#scores_"+as+"_sf2Silver1On").prop("checked") ? (editingRandom == 1 || editingRandom == 6 ? 0b000010 : 0b000100) : 0;
		sf |= $("#scores_"+as+"_sf1Silver1On").prop("checked") ? (editingRandom == 1 || editingRandom == 6 ? 0b010000 : 0b100000) : 0;
		sf |= $("#scores_"+as+"_sf2Silver2On").prop("checked") ? (editingRandom == 3 || editingRandom == 4 ? 0b000010 : 0b000001) : 0;
		sf |= $("#scores_"+as+"_sf1Silver2On").prop("checked") ? (editingRandom == 3 || editingRandom == 4 ? 0b010000 : 0b001000) : 0;
		
			
		obj[as] = {
			adjust:parseInt($("#scores_"+as+"Adjust").val()),
			autoParking1:$("#scores_"+as+"_robot1AutoParked").prop("checked") ? 1 : 0,
			autoParking2:$("#scores_"+as+"_robot2AutoParked").prop("checked") ? 1 : 0,
			card1:($("#scores_"+as+"_team1 .scoreRCDiv input").prop("checked") ? 2 : 0) + ($("#scores_"+as+"_team1 .scoreYCDiv input").prop("checked") ? 1 : 0),
			card2:($("#scores_"+as+"_team2 .scoreRCDiv input").prop("checked") ? 2 : 0) + ($("#scores_"+as+"_team2 .scoreYCDiv input").prop("checked") ? 1 : 0),
			claimed1:$("#scores_"+as+"_robot1Claimed").prop("checked") ? 1 : 0,
			claimed2:$("#scores_"+as+"_robot2Claimed").prop("checked") ? 1 : 0,
			depot:parseInt($("#scores_"+as+"_depot").val()),
			dq1:old ? old.dq1 : 0,
			dq2:old ? old.dq2 : 0,
			endParked1:$("#scores_"+as+"_CraterIn1").prop("checked") ? 2 : ($("#scores_"+as+"_CraterPartial1").prop("checked") ? 1 : 0),
			endParked2:$("#scores_"+as+"_CraterIn2").prop("checked") ? 2 : ($("#scores_"+as+"_CraterPartial2").prop("checked") ? 1 : 0),
			gold:parseInt($("#scores_"+as+"_gold").val()),
			initLatched1: old ? old.initLatched1 : 2,
			initLatched2: old ? old.initLatched2 : 2,
			landed1:$("#scores_"+as+"_robot1Landed").prop("checked") ? 1 : 0, 
			landed2:$("#scores_"+as+"_robot2Landed").prop("checked") ? 1 : 0, 
			latched1:$("#scores_"+as+"_Latched1").prop("checked") ? 1 : 0, 
			latched2:$("#scores_"+as+"_Latched2").prop("checked") ? 1 : 0, 
			major:parseInt($("#scores_"+as+"_major").val()),
			minor:parseInt($("#scores_"+as+"_minor").val()), 
			noshow1:$("#scores_"+as+"_team1 .scoreNoShowDiv input").prop("checked") ? 1 : 0,
			noshow2:$("#scores_"+as+"_team2 .scoreNoShowDiv input").prop("checked") ? 1 : 0,
			noshow3:$("#scores_"+as+"_team3 .scoreNoShowDiv input").prop("checked") ? 1 : 0,
			sampleFieldState:sf,
			silver:parseInt($("#scores_"+as+"_silver").val())
		}
		if(schedule && schedule.length > 0 && schedule[editingIndex].type == "ELIMS"){
			obj[as].card2 = obj[as].card1;
		}
		
	}
	return obj;
}

var lastEditObject;

function scoreEdit(tab, src){
	if(tab == "active"){
		return;
	} 
	
	if(src){

		//The source requires us to alter another button
		if(src.id.indexOf("Off") >=0){
			$("#"+src.id.replace("Off", "On")).prop("checked", false);
		}
		//On handled by update
		
		if(src.id.indexOf("CraterOut") >= 0){
			$("#"+src.id.replace("CraterOut", "CraterPartial")).prop("checked", false);
			$("#"+src.id.replace("CraterOut", "CraterIn")).prop("checked", false);
		}
		if(src.id.indexOf("CraterPartial") >= 0){
			$("#"+src.id.replace("CraterPartial", "CraterIn")).prop("checked", false);
			//out hadled by update
		}
		
		if (schedule && schedule.length > 0 && schedule[editingIndex].type == "ELIMS" && (src.id.indexOf("_yc_") >= 0 || src.id.indexOf("_rc_") >= 0)) {
			selected = $(src).prop("checked");
			baseid = src.id.substring(0, src.id.length - 1);
			$("#" + baseid + "1").prop("checked", selected);
			$("#" + baseid + "2").prop("checked", selected);
			$("#" + baseid + "3").prop("checked", selected);
		}
		//in handled by update
	}
	
	if(editingRandom < 1){
		editingRandom = 1;
	}
	if(editingMatch == activeMatch){		
      $("#lastMatch").addClass("off");
	}
	
	//create score objects to send to backend
	var obj = getScoreObject();
	obj.red = JSON.stringify(obj.red);
	obj.blue = JSON.stringify(obj.blue);
	
	$.ajax({
        url: "./unsavededit/"+editingMatch+"/",
        type: "POST",   
        data: obj,     
        success: function (data) {
        	var d = JSON.parse(data);
            d.red = JSON.parse(d.red);
            d.blue = JSON.parse(d.blue);
            d.redBreakdown = JSON.parse(d.redBreakdown);
            d.blueBreakdown = JSON.parse(d.blueBreakdown);
            lastEditObject = d;
            editingRandom = d.random;
            updateScoreTab("scores", d);
            updateEditButtons();
            console.log(isDirty());
        },
        error: function (xhr, textStatus, errorThrown) {
			console.log("ERROR "+textStatus);
			console.log(xhr);
        }});
        
}


function updateEditButtons(){
	var dirty = isDirty();
    $("#cancelEditsBtn").prop("disabled", !dirty);
    $("#saveEditsBtn").prop("disabled", !dirty);
    $("#commitEditsBtn").prop("disabled", !dirty && (editingMatch < 0 ? testMatches : schedule)[editingIndex].state == "COMMITTED"); //TODO !dirty && committed
    $("#postEditsBtn").prop("disabled", dirty || (editingMatch < 0 ? testMatches : schedule)[editingIndex].state != "COMMITTED"); 
}

function isDirty(){
	//compare the lastEdit Object to the object in scores
	//short names for massive comparison
	var er = lastEditObject.red;
	var eb = lastEditObject.blue;
	var r = (editingMatch < 0 ? testMatches : schedule)[editingIndex].red.scores;
	var b = (editingMatch < 0 ? testMatches : schedule)[editingIndex].blue.scores;
	for(var a = 0; a < 2; a++){
		var o = a == 0 ? r : b;
		var e = a == 0 ? er : eb;
				
		for(var prop in o){
			if(!o.hasOwnProperty(prop) || !e.hasOwnProperty(prop) || o[prop] != e[prop]){
				return true;
			}
		}
	}
	return false;
}

function cancelEdits(){
	//set it back to whats in schedule
	edit(editingMatch);
}
function saveEdits(onComplete){
	var obj = getScoreObject();
	var o2 ={
		red: JSON.stringify(obj.red),
		blue:JSON.stringify(obj.blue)
	}
	$.ajax({
        url: "./edit/"+editingMatch+"/",
        type: "POST",   
        data: o2,     
        success: function (data) {
        	//Disable save and cancel button until dirty 
        	//We need to save the total too.
        	var am = (editingMatch < 0 ? testMatches : schedule)[editingIndex];
        	am.red.scores = lastEditObject.red;
        	am.blue.scores = lastEditObject.blue;
        	am.state = "SUBMITTED";
        	if(editingMatch > 0){
        		var flag = false;
        		for(var i = 0; i < unsavedMatches.length; i++){
        			if(unsavedMatches[i].number == editingMatch){
        				flag = true;
        				break;
        			}
        		}
        		if(!flag){
        			unsavedMatches.push(am);
        		}
        		updateMatch(editingIndex);
        	}
        	renderUnsaved();
        	updateEditButtons();
        	if(onComplete){
        		onComplete();
        	}
        },
        error: function (xhr, textStatus, errorThrown) {
        	// onComplete is a function pointer to what to call after this function
        	// The only time onComplete is specified is if this method was called
        	// preceding a commit. Thus, if the save edit fails and onComplete was
        	// specified, then this needs to trigger a commitFailedAlert
			if(onComplete){
        		commitFailedAlert();
        	}
        }});
}
function commitEdits(){
	//if dirty, save
	//commit
	//if(isDirty()){
		saveEdits(commit.bind(null, editingMatch, updateEditButtons));
	//} else{
		//commit(editingMatch, updateEditButtons);		
	//}
}
function postEdits(){
	post(editingMatch);
}
function disableEditInputs(disable){
	$("#scores_scores_red").find("input").prop("disabled", disable);
	$("#scores_scores_blue").find("input").prop("disabled", disable);
}

//Locks out the match being edited
function lockout(){
	$.ajax({
        url: "./lockout/"+editingMatch+"/",
        type: "POST",   
        data: {},     
        success: function (data) {
			(editingMatch < 0 ? testMatches : schedule)[editingIndex].state = "SUBMITTED";
			renderUnsaved();
			if(editingMatch >= 0){
				//Dont call update match on test match.
				updateMatch(editingIndex);
			}
			edit(editingMatch);
        },
        error: function (xhr, textStatus, errorThrown) {
			console.log("ERROR "+textStatus);
			console.log(xhr);
        }});
}

function lockoutActive(){
	$.ajax({
        url: "./lockout/"+activeMatch+"/",
        type: "POST",   
        data: {},     
        success: function (data) {
			(activeMatch < 0 ? testMatches : schedule)[activeMatchIndex].state = "SUBMITTED";
			renderUnsaved();
			updateMatch(activeMatchIndex);
			if(activeMatch == editingMatch){
				edit(editingMatch);
			}
        },
        error: function (xhr, textStatus, errorThrown) {
			console.log("ERROR "+textStatus);
			console.log(xhr);
        }});
}

function enterUnplayedScores(num){
	edit(num);
}
function loadOOOMatch(number){
	switch(state){
		case STATE_LOADED: 
		case STATE_PRE_RANDOM:
		case STATE_POST_RANDOM:
		case STATE_POST_RANDOM_INIT: 
		case STATE_RANDOM_SHOWN: 
		case STATE_RANDOM_SHOWN_INIT: 
		case STATE_WAIT_FOR_INIT:
		case STATE_READY:
		case STATE_ABORTED:
			popup("Load Different Match?", "This will de-load the currently loaded match, and play will continue from the newly selected match.", loadMatch.bind(null,number));
			break;
		default: //we just loaded the page
			loadMatch(number);
			break;
	}
}

function loadTestMatch(confirmed){
	if(!confirmed && (testLoaded  || (!testLoaded && loadedMatch != -1)) ){
		popup("Load Test Match?", "This will de-load the currently loaded match.", loadTestMatch.bind(null, true));
		return;
	}
	$.ajax({
        url: "./test/",
        type: "POST",   
        data: {
        	red1:$("#testRed1").val(),
        	red2:$("#testRed2").val(),
        	blue1:$("#testBlue1").val(),
        	blue2:$("#testBlue2").val()
        },     
        success: function (data) {
			console.log(data);
			var dat = JSON.parse(data);
			testMatches.push(dat);
			loadedMatch = dat.number;
			unsavedMatches.push(dat);
			testLoaded = true;
			loadedMatchIndex = testMatches.length - 1;
			loadedReady = false;
			nextToLoad = -1;
			$("#loadedName").text(dat.name);
            $("#loadedTime").text("2:30 (Not Started)");
            $("#loadedRed").text("Red: "+dat.red.team1+", "+dat.red.team2+ (dat.red.team3 ? (", "+dat.red.team3) : ""));
            $("#loadedBlue").text("Blue: "+dat.blue.team1+", "+dat.blue.team2+ (dat.blue.team3 ? (", "+dat.blue.team3) : ""));
            redInit = false;
            blueInit = false;
            updateInitIndicator();
            renderUnsaved();
            document.getElementById("loadButton").innerHTML = "Load Next <br>Match";
            
			if(state == STATE_IN_MATCH || state == STATE_NEXT_LOADED || state == STATE_IN_MATCH_NO_NEXT || state == STATE_NEXT_RANDOMIZED){
            	setState(STATE_NEXT_LOADED);
            } else{
            	setState(STATE_LOADED);
            }
            //reset test teams
            $("#testRed1").val(-1);
            $("#testRed2").val(-2); 
            $("#testBlue1").val(-3);
            $("#testBlue2").val(-4);
        },
        error: function (xhr, textStatus, errorThrown) {
			console.log("ERROR "+textStatus);
			console.log(xhr);
        }
    });
}

function editActive(){
	edit(activeMatch);
}

function setEventParam(key, value){
	$.ajax({
		url: "../config/set/",
	    type: "POST",
	    data:{key:key,value:value},
		success: function (data) {
			
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
            console.log("Error Setting param");
        }});
}

function toggleExternalRandom(){
	externalRandom = !externalRandom;
	setEventParam("externalRandom", externalRandom);
	$(".randomTooltip").attr("show", externalRandom);
}

function toggleLS(){
	liveScoring = !liveScoring;
	setEventParam("liveScoring", liveScoring);
	$("#activeTabBtn").prop("disabled", !liveScoring);
	$("#activeTabBtn").attr("title", liveScoring ? "" : "Only available with live scoring");
}

var teamCount = -1;
function renderSelection(data){
	//clear existing selection data
	var available = $("#availableBody");
	available.empty();
	teamCount = 0;
	//Populate Alliances Table
	for(var a = 0; a < 4; a++){
		for(var t = 0; t < 3; t++){
			if(data.alliances[a][t]){
				teamCount++;
			}
			$("#a"+a+t).text(data.alliances[a][t] ? data.alliances[a][t].number : "");
		}
	}
	
	//Populate Available Table
	var captainSlot = data.nextSlot % 2 == 0 && data.nextSlot < 7;
	var captainFlag = captainSlot ? 2 : 0;
	teamCount += data.availableTeams.length;
	console.log(teamCount+" teams");
	for(var i = 0; i < data.availableTeams.length; i++){
		var team = data.availableTeams[i];
		if(team.removed){
			continue;
		}
		var row = $("<tr/>");
		row.append($("<td/>").text(team.rank));
		row.append($("<td/>").text(team.number));
		row.append($("<td/>").addClass("availableName").html(team.name));
		//if they have declined, dont render buttons unless captain
		if(captainFlag){
			row.append($("<td/>").append($("<button/>").addClass("accept").text("Captain").attr("onclick","select("+team.number+", 'CAPTAIN')")));
			captainFlag--;
		} else if(!team.declined && !captainSlot){
			row.append($("<td/>").append($("<button/>").addClass("accept").text("Accept").attr("onclick","select("+team.number+", 'ACCEPT')")));
		}else{
			row.append($("<td/>").attr("title","Team "+team.number+" cannot accept invitation after declining."));
		}
		
		if(captainFlag){
			row.append($("<td/>").append($("<button/>").addClass("decline").text("Remove").attr("onclick","select("+team.number+", 'DECLINE')")));
		}else if(!captainSlot && !team.declined){
			row.append($("<td/>").append($("<button/>").addClass("decline").text("Decline").attr("onclick","select("+team.number+", 'DECLINE')")));
		}else{
			row.append($("<td/>"));
		}
		if(captainFlag == 1){
			captainFlag = 0;
		}
		available.append(row);
	} 

}


function startSelection(confirmed){
	if(!confirmed){
		var count = 0;
		for(var i = 0; i < schedule.length; i++){
			if(schedule[i].state != "COMMITTED"){
				count++;
			}
		}
		if(count > 0){
			popup("Start Alliance Selection?", 
				"WARNING: There are " + count + " un-committed matches. Any Qualification matches committed after starting alliance selection will NOT be considered in the rankings used during Alliance Selection.",
				startSelection.bind(null, true));
			return;
		}
	}
	$.ajax({
		url: "selection/start/",
	    type: "POST",
	    data:{},
		success: function (data) {
			renderSelection(JSON.parse(data));
			$("#startSelection").addClass("off");
			$("#undoButton").removeClass("off");
			$("#generateButton").removeClass("off");
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
            console.log("Error Starting Selection");
        }});
}

function displaySelection(){
	$.ajax({
		url: "selection/show/",
	    type: "POST",
	    data:{},
		success: function (data) {
		
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
            console.log("Error Starting Selection");
        }});
}

function select(team, type, confirmed){
	if(type == "ACCEPT" && !confirmed){
		if(teamCount < 21 && $("#a31").text().length > 0 && $("#a02").text().length == 0){
			popup("Make Selection?", 
					"WARNING: Alliances for this event should be only 2 Teams each. Are you sure you want to continue Alliance Selection?",
					select.bind(null, team, type, true));
			return;
		}
	}
	$.ajax({
		url: "selection/",
	    type: "POST",
	    data:{team:team, type:type},
		success: function (data) {
			renderSelection(JSON.parse(data));
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
        	console.log(textStatus);
            console.log("Error with selection");
        }});
}

function undoSelection(){
	$.ajax({
		url: "selection/",
	    type: "DELETE",
		success: function (data) {
			renderSelection(JSON.parse(data));
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
            console.log("Error Starting Selection");
        }});
}


function generateAlliances(confirmed){
	if(!confirmed){
		//Check for early end. 
		if(teamCount < 21){			
			if($("#a31").text().length == 0){
				popup("Finish Alliance Selection?", 
					"WARNING: Alliances are not full (2 Teams each). Are you sure you want to generate Elimination Matches with these alliances?",
					generateAlliances.bind(null, true));
				return;
			} else if($("#a02").text().length > 0){
				popup("Finish Alliance Selection?", 
					"WARNING: Alliances are too large (max 2 Teams each). Are you sure you want to generate Elimination Matches with these alliances?",
					generateAlliances.bind(null, true));
				return;
			}
		} else{
			if($("#a32").text().length == 0){
				popup("Finish Alliance Selection?", 
					"WARNING: Alliances are not full (3 Teams each). Are you sure you want to generate Elimination Matches with these alliances?",
					generateAlliances.bind(null, true));
				return;
			}
		}
	}
	$.ajax({
		url: "selection/finish/",
	    type: "POST",
		success: function (data) {
			
			showBracket();
			//Clear active and loaded match labels
			$("#activeName").text("");
            $("#activeRed").text("")
            $("#activeBlue").text("");
            $("#activeTime").text("");
            $("#loadedName").text("");
            $("#loadedTime").text("");
            $("#loadedRed").text("");
            $("#loadedBlue").text("");
            redInit = false;
            blueInit = false;
            updateInitIndicator();
            
			//TODO clear active and loaded variables.
			activeMatch = -1;
			activeMatchIndex = -1;
			loadedMatch = -1;
			loadedMatchIndex = -1;
			testActive = false;
			testLoaded = false;
			
			//TODO schedule update!
			getSchedule();
			$("#scoreEditTabBtn").prop("disabled", true);
			setState(STATE_UNLOADED);
			
			//Switch to schedule tab
			$("#scheduleTabButton").click();
			$("#selectionTabBtn").prop("disabled", true);
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
            console.log("Error generating matches!");
        }});
}

function fieldTimeout(){
$.ajax({
		url: "timeout/field/",
	    type: "POST",
		success: function (data) {
			
			if(!toTimer.isRunning()){
				toTimer.setStopTimeSeconds(300);
				toTimer.start();
			} else{
				toTimer.setStopTimeSeconds(300 + toTimer.stopTimeSec);
			}
			$("#fieldTOBtn").addClass("off");
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
            console.log("Error starting field to!");
        }});
	
	
}
function allianceTimeout(){
$.ajax({
		url: "timeout/alliance/",
	    type: "POST",
		success: function (data) {
			
			allianceTO = true;
			if(!toTimer.isRunning()){
				toTimer.setStopTimeSeconds(180);
				toTimer.start();
			} else{
				toTimer.setStopTimeSeconds(180 + toTimer.stopTimeSec);
			}
			$("#allianceTOBtn").addClass("off");
			
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
            console.log("Error starting alliance to");
        }});

}
function showTimeout(){
	$.ajax({
		url: "timeout/show/",
	    type: "POST",
		success: function (data) {			
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
            console.log("Error showing Timeout!");
        }});
}

function endTimeout(){
	$.ajax({
		url: "timeout/end/",
	    type: "POST",
		success: function (data) {	
			$("#allianceTOBtn").removeClass("off");
			$("#fieldTOBtn").removeClass("off");		
			toTimer.end();
	
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
            console.log("Error ending Timeout!");
        }});
}
function showBracket(){
	$.ajax({
		url: "bracket/",
	    type: "POST",
		success: function (data) {			
        },
        error: function (xhr, textStatus, errorThrown) { 
        	//ERROR HANDLING
            console.log("Error showing Bracket!");
        }});
}

function clearTestMatches(){
	$.ajax({
		url:"test/clear/",
		type: "POST",
		success:function(data){
			testMatches = [];
			for(var i = 0; i < unsavedMatches.length; i++){
				if(unsavedMatches[i].number < 0){
					unsavedMatches.splice(i, 1);
				}
			}
			renderUnsaved();
		}, error: function (xhr, textStatus, errorThrown) {
            console.log("Error clearing tests");
       	}
	});
}

